{
  "language": "Solidity",
  "sources": {
    "contracts/Lending.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC20 {\n  function transfer(address to, uint256 amount) external returns (bool);\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n}\n\ninterface ICornDEX {\n  /// @dev Harga 1 ETH dalam CORN (skala 1e18).\n  function currentPrice() external view returns (uint256);\n}\n\ncontract Lending {\n  /* ---------- Constants ---------- */\n  uint256 private constant PRECISION = 1e18;\n  uint256 private constant HUNDRED_PERCENT = 100 * PRECISION;\n\n  /// @notice minimal rasio kolateral 120% (dalam persen * 1e18).\n  uint256 public constant COLLATERAL_RATIO = 120 * PRECISION;\n  /// @notice insentif likuidator 10% (dalam persen * 1e18).\n  uint256 public constant LIQUIDATOR_REWARD = 10 * PRECISION;\n\n  /* ---------- Immutables ---------- */\n  IERC20 public immutable i_corn;\n  ICornDEX public immutable i_cornDEX;\n\n  /* ---------- Storage ---------- */\n  mapping(address => uint256) public s_userCollateral; // ETH (wei)\n  mapping(address => uint256) public s_userBorrowed;   // CORN (1e18)\n\n  /* ---------- Events ---------- */\n  event CollateralAdded(address indexed user, uint256 amountEth, uint256 priceCornPerEth);\n  event CollateralWithdrawn(address indexed user, uint256 amountEth, uint256 priceCornPerEth);\n  event AssetBorrowed(address indexed user, uint256 amountCorn, uint256 priceCornPerEth);\n  event AssetRepaid(address indexed user, uint256 amountCorn, uint256 priceCornPerEth);\n  event Liquidation(address indexed borrower, address indexed liquidator, uint256 repaidCorn, uint256 paidEth, uint256 priceCornPerEth);\n\n  /* ---------- Errors (samakan dengan test) ---------- */\n  error Lending__InvalidAmount();\n  error Lending__InsufficientCollateral();\n  error Lending__InsufficientBorrowed();\n  error Lending__UnsafePositionRatio();\n  error Lending__NotLiquidatable();\n  error Lending__InsufficientLiquidatorCorn();\n  error Lending__TransferFailed();\n  error Lending__RepayingFailed();\n\n  /* ---------- Constructor (URUTANNYA: DEX dulu, lalu CORN) ---------- */\n  constructor(ICornDEX _dex, IERC20 _corn) {\n    i_cornDEX = _dex;\n    i_corn = _corn;\n  }\n\n  /* ---------------- Collateral ---------------- */\n\n  function addCollateral() external payable {\n    if (msg.value == 0) revert Lending__InvalidAmount();\n    s_userCollateral[msg.sender] += msg.value;\n    emit CollateralAdded(msg.sender, msg.value, i_cornDEX.currentPrice());\n  }\n\n  function withdrawCollateral(uint256 amount) external {\n    if (amount == 0) revert Lending__InvalidAmount();\nuint256 current = s_userCollateral[msg.sender];\n// if (amount > current) revert Lending__InsufficientCollateral();\nif (amount > current) revert Lending__InvalidAmount();\n\n\n    unchecked {\n      s_userCollateral[msg.sender] = current - amount;\n    }\n\n    // Jika masih punya utang, pastikan tetap aman setelah penarikan\n    if (s_userBorrowed[msg.sender] > 0) _validatePosition(msg.sender);\n\n    (bool ok, ) = payable(msg.sender).call{value: amount}(\"\");\n    if (!ok) revert Lending__TransferFailed();\n\n    emit CollateralWithdrawn(msg.sender, amount, i_cornDEX.currentPrice());\n  }\n\n  /* ---------------- Helpers ---------------- */\n\n  /// @notice nilai kolateral (ETH) user dalam CORN (1e18)\n  function calculateCollateralValue(address user) public view returns (uint256) {\n    uint256 collateralEth = s_userCollateral[user];\n    uint256 priceCornPerEth = i_cornDEX.currentPrice(); // CORN per 1 ETH (1e18)\n    return (collateralEth * priceCornPerEth) / PRECISION;\n  }\n\n  /// @dev (collateralValue / borrowed) * 100% * 1e18  (contoh 133% => 133e18)\n  function _calculatePositionRatio(address user) internal view returns (uint256) {\n    uint256 borrowed = s_userBorrowed[user];\n    if (borrowed == 0) {\n      return type(uint256).max;\n    }\n    uint256 collateralValueCorn = calculateCollateralValue(user);\n    return (collateralValueCorn * HUNDRED_PERCENT) / borrowed;\n  }\n\n  function isLiquidatable(address user) public view returns (bool) {\n    return _calculatePositionRatio(user) < COLLATERAL_RATIO;\n  }\n\n  function _validatePosition(address user) internal view {\n    if (isLiquidatable(user)) revert Lending__UnsafePositionRatio();\n  }\n\n  /* ---------------- Borrow / Repay ---------------- */\n\n  function borrowCorn(uint256 borrowAmount) external {\n    if (borrowAmount == 0) revert Lending__InvalidAmount();\n\n    s_userBorrowed[msg.sender] += borrowAmount;\n    _validatePosition(msg.sender);\n\n    bool ok = i_corn.transfer(msg.sender, borrowAmount);\n    if (!ok) revert Lending__TransferFailed();\n\n    emit AssetBorrowed(msg.sender, borrowAmount, i_cornDEX.currentPrice());\n  }\n\n  function repayCorn(uint256 repayAmount) external {\n    if (repayAmount == 0) revert Lending__InvalidAmount();\nuint256 borrowed = s_userBorrowed[msg.sender];\n// if (repayAmount > borrowed) revert Lending__InsufficientBorrowed();\nif (repayAmount > borrowed) revert Lending__InvalidAmount();\n\n    s_userBorrowed[msg.sender] = borrowed - repayAmount;\n\n    bool ok = i_corn.transferFrom(msg.sender, address(this), repayAmount);\n    if (!ok) revert Lending__RepayingFailed();\n\n    emit AssetRepaid(msg.sender, repayAmount, i_cornDEX.currentPrice());\n  }\n\n  /* ---------------- Liquidate ---------------- */\n\n  function liquidate(address borrower) external {\n    if (!isLiquidatable(borrower)) revert Lending__NotLiquidatable();\n\n    uint256 debtCorn = s_userBorrowed[borrower];\n    if (debtCorn == 0) revert Lending__NotLiquidatable();\n\n    if (i_corn.balanceOf(msg.sender) < debtCorn || i_corn.allowance(msg.sender, address(this)) < debtCorn) {\n      revert Lending__InsufficientLiquidatorCorn();\n    }\n\n    bool pulled = i_corn.transferFrom(msg.sender, address(this), debtCorn);\n    if (!pulled) revert Lending__TransferFailed();\n\n    // clear utang\n    s_userBorrowed[borrower] = 0;\n\n    // konversi CORN -> ETH berdasar harga DEX\n    uint256 priceCornPerEth = i_cornDEX.currentPrice(); // CORN per 1 ETH\n    uint256 baseEth = (debtCorn * PRECISION) / priceCornPerEth;\n\n    // reward\n    uint256 rewardEth = (baseEth * LIQUIDATOR_REWARD) / HUNDRED_PERCENT;\n    uint256 payEth = baseEth + rewardEth;\n\n    uint256 col = s_userCollateral[borrower];\n    if (payEth > col) payEth = col;\n\n    s_userCollateral[borrower] = col - payEth;\n\n    (bool sent, ) = payable(msg.sender).call{value: payEth}(\"\");\n    if (!sent) revert Lending__TransferFailed();\n\n    emit Liquidation(borrower, msg.sender, debtCorn, payEth, priceCornPerEth);\n  }\n\n  receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}